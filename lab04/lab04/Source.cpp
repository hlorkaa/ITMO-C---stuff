#include <iostream>
#include <fstream>
#include <random>

#define _USE_MATH_DEFINES
#include <math.h>

using namespace std;

// Returns random <double> value from a specified range (by default 0~1) generated by mersenne twister
double randomFromRange(double maximum = 1., double minimum = 0.) { 
    random_device rd;
    mt19937 generator(rd());
    uniform_real_distribution<double> randomValue(minimum, maximum);

    return randomValue(generator);
}

// Structure containing indexes of the two variables closest to the chosen intensity probability (used for the binary search)
struct range {
    int left; // lesser value
    int right; // bigger value
};

// Classic binary search algorithm, returns struct with two integers (left and right indexes of variables closest to the chosen intensity probability)
struct range binarySearch(vector<double> array, double value) {
    range closestValues = {0, array.size()};

    while (closestValues.left + 1 < closestValues.right) {
        int middle = (closestValues.left + closestValues.right) / 2;
        if (array[middle] < value)
            closestValues.left = middle;
        else
            closestValues.right = middle;
    }

    return closestValues;
}

// Rejection sampling with the linear interpolation as a sample
bool rejectionSampling(double leftProbability, double rightProbability, double chosenAngle, double leftAngle, double rightAngle) {
    double probabilitiesInterpolation = leftProbability + (rightProbability - leftProbability) / (rightAngle - leftAngle) * (chosenAngle - leftAngle);
    double randomProbabilityForRS = randomFromRange(std::max(leftProbability, rightProbability));

    return (randomProbabilityForRS >= probabilitiesInterpolation);
}


int main() {
    int numberOfRays;
    double R;

    cout << "Enter number of rays: ";
    cin >> numberOfRays;

    R = 15;
    cout << "Sphere radius: " << R << endl;


    // Vector containing theta angle values from the table
    vector<double> tabularAngles 
    { 
      0.,
      6.,
      12.,
      18.,
      24.,
      30.,
      36.,
      42.,
      48.,
      54.,
      60.,
      66.,
      72.,
      78.,
      84.,
      90.
    };

    // Conversion from degrees to radians (needed for further calculations)
    for (int i = 0; i < tabularAngles.size(); i++) {
        tabularAngles[i] *= M_PI / 180;
    }

    // Vector containing light intensity values from the table for every theta angle
    vector<double> tabularIntensities
    {
      1000.,
      994.5218954,
      978.1476007,
      951.0565163,
      913.5454576,
      866.0254038,
      809.0169944,
      743.1448255,
      669.1306064,
      587.7852523,
      500.,
      406.7366431,
      309.0169944,
      207.9116908,
      104.5284633,
      0.
    };

    // Vector containing probability density values P(theta) for every theta angle from the table
    vector<double> tabularProbabilities;

    for (int i = 0; i < tabularIntensities.size(); ++i) {
        tabularProbabilities.push_back(sin(tabularAngles[i]) * tabularIntensities[i]);
    }

    // Vector containing probability values for the angles inbetween angles from the table (calculated with the trapezoidal rule of integration)
    vector<double> integratedProbabilities;

    for (int i = 0; i < tabularProbabilities.size(); ++i) {
        if (i == 0) { // if angle = 0, then probability is 0
            integratedProbabilities.push_back(0);
            continue;
        }

        double integral = ((tabularProbabilities[i] + tabularProbabilities[i - 1]) / 2) * (tabularAngles[i] - tabularAngles[i - 1]) + integratedProbabilities[i - 1];
        integratedProbabilities.push_back(integral);
    }


    ofstream out;
    out.open("light_10000.ray");

    out << "Rayset\n\tName sphere\n\tColorModel RGB\n\tNormalFlux 1000\n\tScale 1\n\tRayNumber " << numberOfRays << "\n\tRayFlux Relative\n\tRays\n" << endl;

    int rayCounter = 0;
    // For every ray in the rayset
    while (rayCounter < numberOfRays) {

        // Two probability values closest to the generated random one (found with binary search algorithm)
        double randomProbabilityForBoundaries = randomFromRange(integratedProbabilities[integratedProbabilities.size() - 1]);
        range localBoundaries = binarySearch(integratedProbabilities, randomProbabilityForBoundaries);

        double theta = 0.;

        bool isRejected = true;
        while (isRejected) {
            // Random theta angle from the local range with uniform probability distribution
            theta = randomFromRange(tabularAngles[localBoundaries.right], tabularAngles[localBoundaries.left]);

            // Rejection sampling
            isRejected = rejectionSampling(tabularProbabilities[localBoundaries.left], tabularProbabilities[localBoundaries.right], theta, tabularAngles[localBoundaries.left], tabularAngles[localBoundaries.right]);
        }

        double phi = 2 * M_PI * randomFromRange();

        double x = sin(theta) * cos(phi) * R;
        double y = cos(theta) * R;
        double z = sin(theta) * sin(phi) * R;

        out << x << "\t" << y << "\t" << z << "\t" << x << "\t" << y << "\t" << z << "\t" << "1 1 1\n";

        rayCounter += 1;
        int percent = (double)rayCounter / numberOfRays * 100;
        cout << "Progress: " << percent << "%" << '\r' << flush;
    }

    out.close();
    cout << endl << "DONE!" << endl;
    return 0;
}